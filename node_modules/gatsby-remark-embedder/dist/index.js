"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _unistUtilVisit = _interopRequireDefault(require("unist-util-visit"));

var CodePenTransformer = _interopRequireWildcard(require("./CodePen"));

var CodeSandboxTransformer = _interopRequireWildcard(require("./CodeSandbox"));

var SlidesTransformer = _interopRequireWildcard(require("./Slides"));

var SoundCloudTransformer = _interopRequireWildcard(require("./SoundCloud"));

var SpotifyTransformer = _interopRequireWildcard(require("./Spotify"));

var TwitterTransformer = _interopRequireWildcard(require("./Twitter"));

var YouTubeTransformer = _interopRequireWildcard(require("./YouTube"));

const defaultTransformers = [CodePenTransformer, CodeSandboxTransformer, SlidesTransformer, SpotifyTransformer, SoundCloudTransformer, TwitterTransformer, YouTubeTransformer];

const getUrlString = url => {
  const urlString = url.startsWith('http') ? url : `https://${url}`;

  try {
    return new URL(urlString).toString();
  } catch (error) {
    return null;
  }
};

var _default = async ({
  cache,
  markdownAST
}, {
  customTransformers = []
} = {}) => {
  const transformers = defaultTransformers.concat(customTransformers);
  const transformations = [];
  (0, _unistUtilVisit.default)(markdownAST, 'paragraph', paragraphNode => {
    if (paragraphNode.children.length !== 1) {
      return;
    }

    const [node] = paragraphNode.children;
    const isText = node.type === 'text'; // it's a valid link if there's no title, and the value is the same as the URL

    const isValidLink = node.type === 'link' && node.title === null && node.children[0].value === node.url;

    if (!isText && !isValidLink) {
      return;
    }

    const {
      url,
      value = url
    } = node;
    const urlString = getUrlString(value);

    if (!urlString) {
      return;
    }

    transformers.forEach(transformer => {
      if (transformer.shouldTransform(urlString)) {
        transformations.push(async () => {
          let html = await cache.get(urlString);

          if (!html) {
            html = await transformer.getHTML(urlString);
            await cache.set(urlString, html);
          }

          node.type = `html`;
          node.value = html;
          node.children = undefined;
        });
      }
    });
  });
  await Promise.all(transformations.map(t => t()));
  return markdownAST;
};

exports.default = _default;